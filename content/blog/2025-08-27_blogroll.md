+++
date = 2025-08-29
title =  "An XML Misadventure And Its Consequences"
slug =  "blogroll-intro"

[taxonomies]
tags = ["meta", "web", "programming"]

+++

This site now has an official [blogroll!](https://en.wikipedia.org/wiki/Glossary_of_blogging#B) You can check it out [here](/feeds.opml.xml). 

In classic Me fashion, it took a lot of work and multiple dead ends to implement a niche trick most people will never notice or care about. But! I had a fun time and learned a lot about XML. The remainder of this post is to recount that odyssey. 

About a month ago, I got an idea.  The standard way to share subscription lists, the [OPML](https://en.wikipedia.org/wiki/OPML) format, is a dialect of XML; so is HTML. So, can you add HTML stuff to an OPML document to make it render all nice and pretty in a browser, while remaining spec-compliant to import into a feed reader? 


It turns out CSS works for plain XML with no extra configuration needed, so the make-it-pretty part is simple. You just add a processing instruction at the top with a link to the stylesheet: 

```xml
<?xml-stylesheet type="text/css" href="styles.css"?>
```


That improves readability a lot, but it's not ideal

- The OPML lacks `<a>` tags to let the user click on links to open them directly, and we can't make new elements *ex nihilo* with just CSS
- I need to create new styles targeting the OPML-specific elements, which are unconnected to the CSS of the main site. Ideally the existing styles should apply automatically


For the next iteration it's clear we'll need to modify the DOM itself. Luckily, by the power of [XML namespacing](https://en.wikipedia.org/wiki/XML_namespace) we can insert the Web elements we all know and love from the `html` namespace. Like `<script>`[^1]


```xml
<opml version="2.0" xmlns:html="http://www.w3.org/1999/xhtml">
  <head>
    <title>Blogroll</title>
  </head>
  <body>
    <outline text="My Subscriptions">
      <html:script type="text/javascript"><![CDATA[
        alert("Hey, check out this javascript!");
      ]]></html:script>
      <outline text="A subscription" htmlUrl="https://example.com"
        xmlUrl="https://example.com/atom.xml" />
    </outline>
  </body>
</opml>
```

Loaded in a browser this does indeed fire an `alert` window as expected. So, just add some `document.createElement`s in that `script` block to generate a nice HTML table out of the OPML, including clickable links and pretty formatting. 

Except, this doesn't actually work at all:

- DOM elements generated this way don't have any style applied to them in the browser, because the `content-type` of the document is still `text/xml` and the root element is not `<html>`. And by no style I really mean *no style*, including the default browser built-in styles we take for granted. You can generate a table, but it'll just render all its contents unceremoniously on a single line with no formatting. Absolutely dripless.
- Technically there are now `<a>` tags pointing to each site, but for the same reason as above the links aren't actually clickable and are therefore pointless.
- XML parsers are *supposed to* silently ignore elements from namespaces they're not configured to handle, but in practice I think there's a good chance at least some feed readers would not put up with all the `<xmlns:html>` tomfoolery and choke.


I was prepared at this point to just bite the bullet and configure HTML and OPML versions to be generated separately, but as I was poking around Kagi search results for different permutations of "OPML" and "HTML" I found [this blog post](https://btxx.org/posts/rss-click/) on using [XSL](https://en.wikipedia.org/wiki/XSL) transformations to turn an RSS feed into real, genuine HTML, with the right doctype and everything, including clickable links.


Now, I had absolutely no idea XSL existed prior to this. From reading the Wikipedia page and skimming the W3C documentation I picked up a <a href="https://en.wikipedia.org/wiki/Gopher_(protocol)">Gopher</a>-ish vibe; a relic from the Cambrian explosion of old Internet technologies, left behind by the winner-take-all nature of protocol adoption. Not to say there isn't still active XSL adoption in some niches, but here on the Web JSON+JS has decisively won out for client-side markup generation.

The only change needed in the actual OPML is a single processing instruction:

```xml
<?xml-stylesheet type="text/xsl" href="opml.xsl"?>
```


XSL is still supported in all major browsers (except Safari - sorry not sorry Mac users, go enable permissions to cry about it). Opening [implicit.computer/feeds.opml.xml](/feeds.opml.xml) in your browser also fetches and applies the transformations in [implicit.computer/opml.xsl](/opml.xsl), giving you some nice normal HTML that plays perfectly with my existing CSS. Applications that don't support XSL - like RSS aggregators - will just silently ignore that part and get the original OPML.

You can see the whole thing at [/opml.xsl](/opml.xsl), but here's a commented version of the bit that generates the HTML table of feed links[^2]


```xml

<table>
<!-- use an xpath selector to get all <outline> elements directly within an <outline> -->
<!-- the outer <outline> in the original OPML is to keep the imported feeds in a group-->
<!-- and not overwhelm your existing feeds on import-->
  <xsl:for-each select="/opml/body/outline/outline">
  <!-- for each outline, make a table row-->
    <tr>
     <td class="cell-feed-html-link">
        <!--make an element like: --> 
        <!-- <a class ="cell-feed-html-link" href="{htmlUrl}> <span>{displayLink}</span> </a>"-->
        <xsl:element name="a">
          <xsl:attribute name="href">
            <xsl:value-of select="@htmlUrl" />
          </xsl:attribute>
          <span>
            <xsl:value-of select="@displayLink" />
          </span>
        </xsl:element>
      </td>
      <td class="cell-feed-rss-link">
        <!-- make an element like: -->
        <!-- <a href="{@xmlUrl}"> <span> [rss] </span> </a>-->
        <xsl:element name="a">
          <xsl:attribute name="href">
            <xsl:value-of select="@xmlUrl" />
          </xsl:attribute>
          <span>
            [rss]
          </span>
        </xsl:element>
      </td>
    </tr>
  </xsl:for-each>
</table>

```

In retrospect, I fell for the classic blunder of the  [XY problem](https://en.wikipedia.org/wiki/XY_problem). Instead of asking "How can I make an XML document render as HTML in a browser but retain its original format when accessed otherwise?", I latched onto the existing tool I had for client-side DOM manipulation and asked "How can I use Javascript in an XML document to modify its structure?", to which the answer was "with tedious effort and mediocre results." Once I asked the right question, without presupposing a method, the actual solution was straightforward.[^3].


---
[^1]: The `CDATA` block looks funky if you're not familiar with XML, but it's just how you escape a string to prevent it from being interpreted as markup.

[^2]:  Note that `xmlUrl` and `htmlUrl` are standard attributes for OPML, but `displayLink` is something I add with a preprocessor script that's just the html URL minus the `https://` scheme and any query parameters.

[^3]: I won't take all the blame there, though, because Google and Claude both *really really wanted* to use Javascript for this no matter how I phrased my query. Chalk up yet another win for Kagi I guess.
